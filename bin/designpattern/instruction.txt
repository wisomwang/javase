创建式模式

单例模式
一个类只有一个实例，并且提供一个访问该实例的全局访问点
优点：
由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置
，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
实现方式：
饿汉式（线程安全，调用效率高，但是不能延时加载）
懒汉式（线程安全，调用效率不高，但是可以延时加载）
双重检测锁式（由于JVM底层内部模式原因，偶尔会出问题，不建议使用）
静态内部类式（线程安全，调用效率高，同时也是延时加载
反射可以破解上面四种方式

枚举单例（线程安全，调用效率高，不能延时加载,避免通过反射和反序列化的漏洞）


工厂模式
简单工厂模式（静态模式）
通过类的静态方法,每新加一种汽车，需要增加一个else if clause

工厂方法模式
声明一个工厂接口，定义具体的子工厂
interface CarFactory
----AudiFactory
--------createCar()
----BydFactory
--------createCar()

Car
----Audi
----Byd
每次新加一种汽车，都要增加一个工厂类

抽象工厂模式
创建多个接口下面的厂品的时候，厂品族
发动机
----高端发动机
----低端发动机

坐椅
----高端坐椅
----低端发动机

轮胎
----高端轮胎
----低端发动机

建造者模式
客户端---->装配者---->建造者

原型模式
浅复制
深复制，对属性也进行复制
序列化和反序列化实现深克隆
ObjectOutputStream(ByteArrayOutPutStream)
ObectInputStream(ByteArrayInputStream)

场合：通过new创建对象很耗时，短时候间需要创建大量的对象

结构型模式
适配器模式
将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
目标接口(Target)
需要适配的类(Adaptee)
适配器(Adapter)

类适配器
继承被适配者

对象适配器
组合模式

场合
经常用来做系统改造和升级
在jdk中,InputStreamReader就是一个很经典的例子，把字节流转换成字符流,InputStreamReader就是一个Adapter，他继承了抽象类
Reader，内部有一个StreamDecoder，StreamDecoder有一个属性InputStream相当于是被适配者,所有的操作都委托给StreamDecoder


桥接模式
用组合来替换继承
商场里卖电脑，有台式机，笔记本，pad,有联想品牌，dell品牌，神舟品牌

				联想台式机
       	台式机	dell台式机
       			神舟台式机
       			
       			联想笔记本
电脑		笔记本	dell笔记本
				神舟笔记本
		
				联想PAD
		PAD		dellPAD
				神舟PAD
如果再新增一种电脑类型，如XX电脑，则每个品牌都必须新增加一个，相当于要新增四个类，类增长的很快
这相当于把两种职责电脑类型和品牌都放在一个类上，我们要把脱离，电脑类型归电脑类型，品牌归品牌

装饰模式
动态的为对象添加新的功能
装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能，使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系
的快速膨胀

实现细节
Component抽象构件角色
	真实对象和装饰对象有相同的接口，这样客户端对象就能够以与真实对象相同的方式同装饰对象交互
ConcreteComponent具体构件角色（真实对象）
	io流中的FileInputStream, FileOutputstream
Decorator装饰角色
	持有一个抽象构件的引用，装饰对象接受所客户端的请求，并把这些请求转发给真实的对象，这样，就能
	在真实对象调用前后增加新的功能
ConcreteDecorator
	负责给构件对象增加新的责任
	
总结
装饰模式也叫包装器模式，装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要
装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体妆饰类

优点
扩展对象功能，比继承灵活，不会导致类个数急剧增加
可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类

缺点
产生很多小对象，大量小对象占据内存，一定程度上影响性能
装饰模式易于出错，调试比较麻烦
	
组合模式


外观模式
为子系统提供一个统一的接口，封闭子系统的复杂性，便于客户端调用

享元模式
场合
内存属于稀缺资源，如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存

核心
享元模式以共享的方式高效地支持大量细粒度对象的重用

享元对象能够做到共享的关键地区分了内部状态和外部状态
内部状态：可以共享，不会随环境变化而变化
外部状态：不可以共享，会随环境变化而变化

代理模式
类似经纪人，房产中介

核心角色三个
抽象角色
定义代理角色和真实角色的公共方法 

真实角色
实现抽象角色，定义真实角色所要实现的业务逻辑供代理角色调用
关注真正的业务逻辑

代理角色
实现抽象角色，是真实角色的代理，通过真实角色的业务方法来实现抽象方法，并且可以附加自己的操作
将统一的流程控制放到代理角色中处理

静态代理(静态自定代理类)

动态代理(动态生成代理类)
代理类不需要自己创建
JDK
java.lang.reflect.Proxy动态生成代理类和对象
java.lang.reflect.InvocationHandler处理器接口
可以通过invoke方法实现对真实角色的代理访问
每次通过Proxy生成代理类象时都要指定对应的处理器对象

javaassit
CGLIB
ASM

行为型模式
模板方法模式
某个业务过程是由几个具体的步骤构成的，如请客
1.点菜（点菜方式可能不一样）
2.吃东西(吃什么东西不确定)
3.买单（买单方式可能不一样）

定义
定义了一个操作中的算法骨架（步骤可以在父类中定义）将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构
的前提下重新定义该算法的某些特定步骤

核心
处理某个流程流程的代码都已具备，但是其中某个节点的代码暂时不能确定，因此我们采用模板模式

开发中常见的场景
数据库访问的封装(打开连接，具体业务处理，关闭连接)
数据库事务的封装（开启一个事务，具体业务处理，关闭一个事务）
Junit单元测试(setup, 具体测试方法，teardown)
spring中JdbcTemplate,hibernateTemplate

命令模式
使用场合不多

角色
Command抽象命令类
ConcreteCommand具体命令类
Invoker调用者、请求者
请求的发送者，它通过命令对象来执行请求，一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类存在关联。在程序运行时，
将调用具体的命令对象，间接调用接收者的相关操作
Receiver接收者
接收者执行与请求相关的操作，具体实现对请求的业务处理
Client
在客户类中需要创建调用者对象，具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接
调用

了解哪些场合用到
数据库事务机制的底层实现
命令的撤销和恢复
jdk的Executor

迭代器模式
跟jdk提供的类似，就不学习了

观察者模式
Subject----Observer
jdk的Observer,Observable

中介者模式
通过中介者来协调多方，比方说一个公司有多个部门，各个部门都会向总经理汇报，
有事情总经理会找各个部门，避免了部门与部门之间直接沟通的麻烦

核心
如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂
这些对象称为"同事对象"，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，
将复杂的网络化解为如下的星形结构

角色
抽象者中介者
具体中介者

抽象者同事
具体同事

MVC中的控制器就是一个中介者角色

备忘录模式
保存了对象的内部状态
回复到以前的状态

场景
Word文档编辑时，忽然死机或断电，结果重新打开时，提示你恢复
数据库事务中的回滚操作

解释器模式
不学了，只有在创建一种新的语言中使用

状态模式
场景
电梯的运行
维修、正常、自动关门、向上运行、向下运行

红绿灯
红灯、黄灯、绿灯

网上购物时，订单的状态
下单
已付款
已发货
送货中
已收货

酒店系统间，房间的状态变化
已预订
已入住
空闲

策略模式
角色
抽象策略接口

具体策略

上下文
持有一个策略的属性

本质
分离算法，选择实现

开发场景
java GUI编程中布局管理器
Spring框架中，Resource接口的资源访问策略
HttpServlet的service方法
到底调用doGet还是doPost

职责链模式
场合
报销单的审批流程
请假的审批流程
奖学金的审批流程
供应链管理
采购管理

角色
抽象处理者
内部有一个属性持有下一个处理者

具体处理者
继承抽象处理者

请求
发送给处理者处理

访问者模式